diff -urNd a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
--- a/drivers/usb/core/hub.c	2010-05-27 05:29:57.000000000 +0800
+++ b/drivers/usb/core/hub.c	2010-10-09 17:45:19.916774688 +0800
@@ -29,6 +29,7 @@
 #include "usb.h"
 #include "hcd.h"
 #include "hub.h"
+#include "mach/hardware/solosw_gpio.h"
 
 /* if we are in debug mode, always announce new devices */
 #ifdef DEBUG
@@ -82,6 +83,8 @@
 };
 
 
+volatile int CURRENT_USB_DEVICE =0;
+volatile int CURRENT_HUB_DEVICE =0;
 /* Protect struct usb_device->state and ->children members
  * Note: Both are also protected by ->dev.sem, except that ->state can
  * change to USB_STATE_NOTATTACHED even when the semaphore isn't held. */
@@ -402,6 +405,12 @@
 	unsigned i;
 	unsigned long bits;
 
+	/* Setting mode as INVOUTPUT again
+	 * when we do startbsp then again some task make mode to OUTPUT
+	 * and from then it start in opposite mode
+	 */
+	solosw_gpio_set_mode(SOLOSW_GPIO_3, SOLOSW_GPIO_CONTROL_INVOUTPUT);
+
 	switch (status) {
 	case -ENOENT:		/* synchronous unlink */
 	case -ECONNRESET:	/* async unlink */
@@ -1142,6 +1151,8 @@
 {
 	struct usb_hub *hub = usb_get_intfdata (intf);
 
+	CURRENT_HUB_DEVICE--;
+	//printk("%s: Entered CURRENT_HUB_DEVICE %d\n", __FUNCTION__,CURRENT_HUB_DEVICE);
 	/* Take the hub off the event list and don't let it be added again */
 	spin_lock_irq(&hub_event_lock);
 	list_del_init(&hub->event_list);
@@ -1175,6 +1186,8 @@
 	struct usb_device *hdev;
 	struct usb_hub *hub;
 
+	CURRENT_HUB_DEVICE++;
+	//printk("%s: Entered CURRENT_HUB_DEVICE %d\n", __FUNCTION__,CURRENT_HUB_DEVICE);
 	desc = intf->cur_altsetting;
 	hdev = interface_to_usbdev(intf);
 
@@ -1533,6 +1546,12 @@
  *
  * This call is synchronous, and may not be used in an interrupt context.
  */
+
+#ifdef CONFIG_CNXT_HOTPLUG
+static struct task_struct *user_app = NULL; 
+extern char pid_str[];
+#endif
+
 void usb_disconnect(struct usb_device **pdev)
 {
 	struct usb_device	*udev = *pdev;
@@ -1552,6 +1571,23 @@
 
 	usb_lock_device(udev);
 
+#ifdef CONFIG_CNXT_HOTPLUG
+	{
+		long pid = simple_strtol(pid_str, NULL, 10); 
+
+		if ( pid != 0 )
+		{
+			//printk("PID from USB module, %d\n", pid);
+			user_app = find_task_by_pid(pid);
+			/* send SIGUSR2 */
+			if(user_app)
+			{
+				send_sig(12, user_app, 0);
+			}
+		}
+	}
+#endif
+
 	/* Free up all the children before we remove this device */
 	for (i = 0; i < USB_MAXCHILDREN; i++) {
 		if (udev->children[i])
@@ -3649,6 +3685,24 @@
 	return -ENODEV;
 }
 
+
+/* This function returns true is any device is connected to the
+ * usb-host/usb-hub.
+ */
+int usb_device_connected()
+{
+	if ((CURRENT_USB_DEVICE) > (CURRENT_HUB_DEVICE))
+	{
+		return 1;
+	}
+	else
+	{
+		return 0;
+	}
+}
+EXPORT_SYMBOL(usb_device_connected);
+
+
 /**
  * usb_reset_device - warn interface drivers and perform a USB port reset
  * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)
diff -urNd a/drivers/usb/core/inode.c b/drivers/usb/core/inode.c
--- a/drivers/usb/core/inode.c	2010-05-27 05:29:57.000000000 +0800
+++ b/drivers/usb/core/inode.c	2010-10-09 17:50:07.890568662 +0800
@@ -48,6 +48,9 @@
 #define USBFS_DEFAULT_BUSMODE (S_IXUGO | S_IRUGO)
 #define USBFS_DEFAULT_LISTMODE S_IRUGO
 
+extern volatile int CURRENT_USB_DEVICE;
+extern volatile int CURRENT_HUB_DEVICE;
+
 static const struct file_operations default_file_operations;
 static struct vfsmount *usbfs_mount;
 static int usbfs_mount_count;	/* = 0 */
@@ -713,6 +716,7 @@
 	}
 	if (dev->usbfs_dentry->d_inode)
 		dev->usbfs_dentry->d_inode->i_size = i_size;
+	CURRENT_USB_DEVICE++;
 }
 
 static void usbfs_remove_device(struct usb_device *dev)
@@ -721,6 +725,7 @@
 		fs_remove_file (dev->usbfs_dentry);
 		dev->usbfs_dentry = NULL;
 	}
+	CURRENT_USB_DEVICE--;
 }
 
 static int usbfs_notify(struct notifier_block *self, unsigned long action, void *dev)
